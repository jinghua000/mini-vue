// 第一位与最后一位一定不相同

const arr1 = [
    2, 4, 5, 7
]

const arr2 = [
    4, 7, 5, 6
]

// 假设上下两个数组为两个节点数组，每个数字代表节点的key，则替换方式为

// 计算新节点哪些是可以通过patch得到而不需要新建的
const keyToNewMap = [1, 3, 2, -1]

// 再遍历旧的数组，根据下标，把不存在的下标对应的节点删除，存在的进行patch运算。

// 这样之后保证了两点：
// 1. 所有的节点都是经过patch后的新节点
// 2. 所有多余的旧节点已经全部删除了

// 接下来就是尽可能的把已经patch过的节点移动到新的位置

// 此时计算最长递增子序列，因为最长递增序列的相对位置不需要变化
// 比如 本身某连个节点 a, ..., x，无论中间新增还是减少节点，a永远是在x前面
// 而最长递增序列表示的就是最多可以计算得出的，肯定不需要改变位置的节点

const increasingNewIndexSequence = [1, 2]
const increasingNewIndexSequenceIndex = [0, 2] // 下标数组

// 上例子中是[1, 2]，意思就是说旧节点的4, 7相对位置是不需要改变的

// 然后遍历新的数组

// 如果某一个节点对应的keyToNewMap则直接创建，表示以前没有这个节点
// 然后不需要移动的节点一共有2个
// 意思就是说 4, 7, 5, 6 中除了一个新创建的节点6， 4, 7, 5 中有两个节点是不需要移动的，且相对位置固定
// 那么就可以 从后往前 遍历
// 记录一个指针指向最长递增子序列的最后一位 

// 此时指针为2

// 如果当前的节点是下标对应的是指针指向的下标，比如最后一位 2，则不需要变化，指针往前移动一位

// 此时指针为0

// 如果当前节点下标不是对应指针的下标，但是又存在于旧数组中，则把当前节点插入到数组后一位的节点的前面
// 把7插入到5的节点的前面
